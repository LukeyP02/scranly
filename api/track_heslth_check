#!/usr/bin/env python3
import sys, os, sqlite3, json, textwrap

DEFAULT_DB = os.getenv("DB_PATH", "/Users/lukeyp02/Desktop/scranly/api/data/scranly.db")

def connect(db_path: str) -> sqlite3.Connection:
    if not os.path.exists(db_path):
        raise SystemExit(f"‚ùå DB not found: {db_path}")
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn

def main(db_path: str):
    print(f"üîó DB: {db_path}")
    conn = connect(db_path)
    cur = conn.cursor()

    # Ensure table/column exist
    try:
        cur.execute("PRAGMA table_info(meals)")
        cols = {row["name"] for row in cur.fetchall()}
        if "nutrition_json" not in cols:
            raise SystemExit("‚ùå Column 'nutrition_json' not found in 'meals' table.")
        if "id" not in cols:
            raise SystemExit("‚ùå Column 'id' not found in 'meals' table.")
    except sqlite3.Error as e:
        raise SystemExit(f"‚ùå Failed to introspect 'meals': {e}")

    # Counts
    total = cur.execute("SELECT COUNT(*) FROM meals").fetchone()[0]
    with_nutri = cur.execute("""
        SELECT COUNT(*) FROM meals
        WHERE nutrition_json IS NOT NULL AND TRIM(nutrition_json) <> ''
    """).fetchone()[0]
    without_nutri = total - with_nutri

    print(f"üì¶ meals total       : {total}")
    print(f"ü•ó with nutrition    : {with_nutri}")
    print(f"üï≥Ô∏è  without nutrition : {without_nutri}")

    # Fetch some examples
    rows = cur.execute("""
        SELECT id, nutrition_json
        FROM meals
        WHERE nutrition_json IS NOT NULL AND TRIM(nutrition_json) <> ''
        LIMIT 12
    """).fetchall()

    key_counts = {}
    json_errors = []
    examples = []

    # Scan all rows (not just the first 12) to get accurate key stats
    scan = cur.execute("""
        SELECT id, nutrition_json
        FROM meals
        WHERE nutrition_json IS NOT NULL AND TRIM(nutrition_json) <> ''
    """)
    for r in scan:
        _id = str(r["id"])
        raw = r["nutrition_json"]
        try:
            obj = json.loads(raw)
            if isinstance(obj, dict):
                for k in obj.keys():
                    key_counts[k] = key_counts.get(k, 0) + 1
            else:
                # If the JSON isn't a dict (e.g. list), still count ‚Äú__non_dict__‚Äù
                key_counts["__non_dict__"] = key_counts.get("__non_dict__", 0) + 1
        except Exception as e:
            json_errors.append((_id, str(e)))

    # Collect formatted examples (from the limited rows)
    for r in rows:
        _id = str(r["id"])
        raw = r["nutrition_json"]
        try:
            obj = json.loads(raw)
            pretty = json.dumps(obj, indent=2, ensure_ascii=False)
        except Exception as e:
            pretty = f"<< invalid JSON: {e} >>"
        examples.append((_id, pretty))

    # Print examples
    if examples:
        print("\nüîé Examples (up to 12):")
        for _id, pretty in examples:
            print(f"\n‚Äî id: { _id }")
            print(textwrap.indent(pretty, "   "))
    else:
        print("\nüîé No example rows with nutrition_json found.")

    # Key frequency summary
    if key_counts:
        print("\nüßæ Key frequency (across ALL nutrition_json rows):")
        # highlight typical macro keys first
        preferred = ["calories", "protein", "carbs", "fat", "fats"]
        for k in preferred:
            if k in key_counts:
                print(f"   {k:>10} : {key_counts[k]}")
        # then the rest
        for k, v in sorted(key_counts.items()):
            if k in preferred: 
                continue
            print(f"   {k:>10} : {v}")
    else:
        print("\nüßæ No keys found (are all JSON blobs empty/invalid?).")

    # JSON errors
    if json_errors:
        print("\n‚ö†Ô∏è Rows with invalid nutrition_json:")
        for _id, err in json_errors[:20]:
            print(f"   id={_id} ‚Üí {err}")
        if len(json_errors) > 20:
            print(f"   ‚Ä¶ and {len(json_errors)-20} more")

    conn.close()
    print("\n‚úÖ Done.")

if __name__ == "__main__":
    db = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_DB
    main(db)